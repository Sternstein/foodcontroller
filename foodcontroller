#!/usr/bin/env ruby
require "rubygems" # ruby1.9 doesn't "require" it though
require "rainbow"
require "thor"
require "terminal-table"
require "pg"


class MyThorCommand < Thor
  desc "new", "Puts new food in database. Put arguments in the order"
  def new
		puts "List of templates : "
				
		conn = PG.connect( dbname: 'fooddb', user: ENV['USER'], password: ENV['PASS'] )
    res = conn.exec( "SELECT id,name FROM templates;" )
    rows = []
    rows << ['id', 'name']
    res.each do |row|
    rows << [row['id'], row['name']]
    end
    table = Terminal::Table.new :rows => rows
    puts table
		
		ans = ask "Please choose a template : "
    a = ans.to_i
		amount = ask "How much do you have : "
		am = amount.to_i		
		conn.exec("INSERT INTO food(template_id,amount) VALUES (#{a}, #{am});")
		puts "Insert in db #{a} and #{am}"
		conn.close
  end

	desc "template", "Work with food templates"
	method_option :init, :aliases => "-i", :desc => "Init db of templates"  	
	method_option :list, :aliases => "-l", :desc => "Show list of templates"  	
	method_option :create, :aliases => "-c", :desc => "Create new template"  	
	method_option :drop, :aliases => "-d", :desc => "Drop db"
	def template
	list = options[:list]
	init = options[:init]
	create = options[:create]
	drop = options[:drop]
  if init
			conn_f = PG.connect( dbname: 'fooddb', user: ENV['USER'], password: ENV['PASS'] )
			sql_check = "SELECT tablename FROM pg_catalog.pg_tables WHERE  schemaname != 'pg_catalog'
AND schemaname != 'information_schema';"
			sql_init = "CREATE TABLE templates(id SERIAL, name varchar, speed integer, expire integer, measure varchar);"
			res = conn_f.exec(sql_check)
			arr = Array.new
			res.each do |r|
				arr.push(r['tablename'])
			end
			if arr.include?("templates")
				puts "Table is already exists!"
			else
			conn_f.exec(sql_init)
			puts "CREATE TABLE templates" 
			end	
			res.clear
			conn_f.close
	end
  if drop
			conn_f = PG.connect( dbname: 'fooddb', user: ENV['USER'], password: ENV['PASS'] )
			sql_check = "SELECT tablename FROM pg_catalog.pg_tables WHERE  schemaname != 'pg_catalog'
AND schemaname != 'information_schema';"
			sql_d = "DROP TABLE templates;"
			res = conn_f.exec(sql_check)
			arr = Array.new
			res.each do |r|
				arr.push(r['tablename'])
			end
			if arr.include?("templates")
				puts "Dropping"
        conn_f.exec(sql_d)
			else
			puts "Table doesn't exists" 
			end
			res.clear
			conn_f.close
	end
	
  if list
    conn = PG.connect( dbname: 'fooddb', user: ENV['USER'], password: ENV['PASS'] )
    result = conn.exec( "SELECT * FROM templates;" )
    rows = []
    rows << ['id', 'name', 'speed', 'expire', 'measure']
    result.each do |row|
    rows << [row['id'], row['name'],row['speed'],row['expire'],row['measure']]
    end
    table = Terminal::Table.new :rows => rows
    puts table
	end
	if create
		name = ask "Put name of food : "
		grmg = Array.new
		grmg = ["gr", "mg", "p"]
		correct_answer = nil
			until correct_answer				
				measure = (ask "Enter measure Gramms/Milligrams/Pieces : ", :limited_to => ["gr", "mg", "p"])
				correct_answer = grmg.include?(measure) ? measure : nil
				say ("Your response must be one of: gr / mg. Please try again.") unless correct_answer
				correct_answer
			end
			
		speed = ask "How fast will you eat it : "
    expire = ask "How long you can keep it : "
		sp = speed.to_i
    ex = expire.to_i
    conn = PG.connect( dbname: 'fooddb', user: ENV['USER'], password: ENV['PASS'] )
    conn.exec( "INSERT INTO templates(name,speed,expire,measure) values ('#{name}', '#{sp}' , '#{ex}' , '#{measure}');" )
    puts "Put in table: "+ Rainbow("OK").orange
		conn.close
	end
	end

  desc "show", "Show all food"
  def show
    conn = PG.connect( dbname: 'fooddb', user: ENV['USER'], password: ENV['PASS'] )
    result = conn.exec( "select food.id as id,templates.name as name,food.amount as amount from food inner join templates on food.template_id=templates.id;" )
    rows = []
    rows << ['id', 'name', 'amount']
    result.each do |row|
		rows << [row['id'], row['name'],row['amount']]
    end
    table = Terminal::Table.new :rows => rows
    puts table
  end

  desc "db", "Works with database"
	method_option :create, :aliases => "-c", :desc => "Create db"  
	method_option :drop, :aliases => "-d", :desc => "Drop db"  
	method_option :init, :aliases => "-i", :desc => "Init db"  	
	def db
		check_if_exist = "SELECT datname FROM pg_database WHERE datistemplate = false;"
		create = options[:create]
		drop = options[:drop]
		init = options[:init]
		if create
      conn = PG.connect( dbname: ENV['USER'], user: ENV['USER'], password: ENV['PASS'] )
			res = conn.exec(check_if_exist)
			arr = Array.new
			res.each do |r|
				arr.push(r['datname'])
			end
			if arr.include?("fooddb")
				puts "Database is already exists!"
			else
			sql_create = "CREATE DATABASE fooddb;"
			conn.exec(sql_create)
			puts "CREATE DATABASE fooddb"
			end	
			res.clear
			conn.close
		end
		if drop
      conn = PG.connect( dbname: ENV['USER'], user: ENV['USER'], password: ENV['PASS'] )
			res = conn.exec(check_if_exist)
			arr = Array.new
			res.each do |r|
				arr.push(r['datname'])
			end
			if arr.include?("fooddb")
			sql_drop = "DROP DATABASE fooddb;"
			conn.exec(sql_drop)
			puts "DROP DATABASE fooddb"
		 	else
			puts "Database doesn\'t exists"	
			end
			res.clear
			conn.close
		end
		if init
			conn_f = PG.connect( dbname: 'fooddb', user: ENV['USER'], password: ENV['PASS'] )
			sql_check = "SELECT tablename FROM pg_catalog.pg_tables WHERE  schemaname != 'pg_catalog'
AND schemaname != 'information_schema';"
			sql_init = "CREATE TABLE food(id SERIAL, template_id integer, amount integer);"
			res = conn_f.exec(sql_check)
			arr = Array.new
			res.each do |r|
				arr.push(r['tablename'])
			end
			if arr.include?("food")
				puts "Table is already exists!"
			else
			conn_f.exec(sql_init)
			puts "CREATE TABLE food" 
			end	
			res.clear
			conn_f.close
		end
  end
end


MyThorCommand.start
